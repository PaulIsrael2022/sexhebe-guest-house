import { supabase } from '../lib/supabase';
import type { Booking } from '../types';
import { quotationService } from './quotationService';
import { differenceInDays, format } from 'date-fns';
import { settingsService } from './settingsService'; // Import settingsService

const BOOKING_SELECT = `
  *,
  guests (
    id,
    first_name,
    last_name,
    email,
    phone,
    id_number
  ),
  rooms (
    id,
    room_number,
    room_type,
    price_per_night
  )
`;

export const bookingService = {
  async getAllBookings(): Promise<Booking[]> {
    try {
      const { data, error } = await supabase
        .from('bookings')
        .select(BOOKING_SELECT)
        .order('check_in', { ascending: true });
      
      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Failed to get all bookings:', error);
      throw error;
    }
  },
  
  async createBooking(booking: Omit<Booking, 'id' | 'created_at' | 'updated_at'>): Promise<Booking> {
    try {
      // Calculate tax and total
      const nights = differenceInDays(new Date(booking.check_out), new Date(booking.check_in));
      const subtotal = booking.price_per_night * nights;

      // Create the booking
      const { data, error } = await supabase
        .from('bookings')
        .insert([booking])
        .select('*, rooms (*), guests (*)')
        .single();

      if (error) throw error;

      // Create quotation
      const quotationData = {
        number: '', // Will be generated by quotationService
        guest_id: booking.guest_id,
        amount: 0, // Will be calculated later
        subtotal: subtotal,
        tax: 0, // Will be calculated later
        status: 'draft',
        valid_until: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days validity
        date: new Date().toISOString(),
        items: [
          {
            description: `Room ${data.rooms.room_number} - ${data.rooms.room_type}`,
            quantity: nights,
            unit_price: booking.price_per_night,
            total: booking.price_per_night * nights
          }
        ],
        notes: `Booking period: ${format(new Date(booking.check_in), 'MMM d, yyyy')} to ${format(new Date(booking.check_out), 'MMM d, yyyy')}`
      };

      const { subtotal: calculatedSubtotal, tax: calculatedTax, total: calculatedTotal, taxLabel } = await bookingService.calculateQuotationTotal(quotationData.items);
      quotationData.amount = calculatedTotal;
      quotationData.tax = calculatedTax;
      quotationData.subtotal = calculatedSubtotal;
      quotationData.items.push({
        description: taxLabel,
        quantity: 1,
        unit_price: calculatedTax,
        total: calculatedTax
      });

      await quotationService.createQuotation(quotationData);

      return data;
    } catch (error) {
      console.error('Failed to create booking:', error);
      throw error;
    }
  },

  async calculateQuotationTotal(items: any[]): Promise<{ subtotal: number; tax: number; total: number; taxLabel: string }> {
    const subtotal = items.reduce((sum, item) => sum + (item.unit_price * item.quantity), 0);
    const { taxAmount, taxLabel } = await settingsService.calculateTax(subtotal);
    
    return {
      subtotal,
      tax: taxAmount,
      total: subtotal + taxAmount,
      taxLabel
    };
  },

  async getBookingsByDateRange(startDate: Date, endDate: Date): Promise<Booking[]> {
    try {
      const { data, error } = await supabase
        .from('bookings')
        .select(BOOKING_SELECT)
        .gte('check_in', startDate.toISOString())
        .lte('check_out', endDate.toISOString())
        .order('check_in', { ascending: true });
      
      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Failed to get bookings by date range:', error);
      throw error;
    }
  },

  async updateBookingStatus(id: string, status: Booking['status']): Promise<void> {
    try {
      const { error } = await supabase
        .from('bookings')
        .update({ 
          status,
          updated_at: new Date().toISOString()
        })
        .eq('id', id);
      
      if (error) throw error;
    } catch (error) {
      console.error('Failed to update booking status:', error);
      throw error;
    }
  },

  async getBookingById(id: string): Promise<Booking | null> {
    try {
      const { data, error } = await supabase
        .from('bookings')
        .select(BOOKING_SELECT)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Failed to get booking by id:', error);
      throw error;
    }
  },

  async deleteBooking(id: string): Promise<void> {
    const { error } = await supabase
      .from('bookings')
      .delete()
      .eq('id', id);

    if (error) throw error;
  }
};